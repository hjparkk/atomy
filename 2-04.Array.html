<!DOCTYPE html>
<html>
<head>
    <title>Document</title>
</head>
<body>
    <div id="div1"></div>
    <script>
        //toString()
        var fruits = ["Banana","Orange","Apple"];
        console.log(fruits.toString()); //Banana,Orange,Apple > 하나의 문자열로 만들어준다.        

        //join()
        console.log(fruits.join(" * ")); //Banana * Orange * Apple 
        //콤보박스 안에 옵션이나 테이블 안에 들어가는 행들을 자바스크립트에서 만들어서 화면에 랜더링할 경우
        var txt = "Banana<br>";
        txt += "Orange<br>";
        txt += "Apple";
        //document.getElementById("div1").innerHTML = txt;
        //서버에서 불러오는 갯수 만큼, 100개든~ 
        //테이블에 행태그로 추가 ++ 
        //코드가 굉장히 복잡하고 가독성이 떨어지게 된다.
        //배열 선언
        //push > 값을 넣는다. > 훨씬 빠르다

        var arr = [];
        arr.push("Banana");
        arr.push("Orange");
        arr.push("Apple");
        document.getElementById("div1").innerHTML = arr.join("<br>");

        //pop()
        //배열의 가장 마지막 element를 제거
        //pop()하면, 제거된 elelment를 리턴 함.
        var arr2 = fruits.pop();
        console.log(arr2);
        console.log(fruits); // ['Banana', 'Orange'] > 배열의 가장 마지막 element를 제거

        //push()
        //배열에 마지막에 새 element에 추가
        fruits.push("Kiwi");
        console.log(fruits); //['Banana', 'Orange', 'Kiwi']

        //shift()
        //배열의 첫번째 element를 제거 함
        //shift() 리턴으로 제거된 element를 반환
         var str = fruits.shift();
         console.log(str); //Banana
         console.log(fruits); // ['Orange', 'Kiwi']

         //unshift()
         //배열의 첫번째에 새 element 추가
         fruits.unshift("Lemon");
         console.log(fruits); //['Lemon', 'Orange', 'Kiwi']

         fruits[0] = "Banana";
         console.log(fruits); //['Banana', 'Orange', 'Kiwi']

         fruits[fruits.length-1] = "Lemon";
         console.log(fruits); //['Banana', 'Orange', 'Lemon']

         //splice 스플라이스
         //첫번째 파라미터 - 시작 위치
         //두번째 - 삭제할 element의 수
         var fruits = ["Banana","Orange","Apple"];
         fruits.splice(1,0,"Lemon","Kiwi");
         console.log(fruits); //['Banana', 'Lemon', 'Kiwi', 'Orange', 'Apple']
         fruits.splice(1,1,"Lemon","Kiwi");
         console.log(fruits); //['Banana', 'Lemon', 'Kiwi', 'Apple']

         //concat() 컨켓
         //배열을 합쳐준다.
         var myBoys = ["Eunhyeok"];
         var myGirls = ["Eunseo", "Eunsol"];
         var myChildren = myBoys.concat(myGirls);
         console.log(myChildren); // ['Eunhyeok', 'Eunseo', 'Eunsol']

         //slice() 슬라이스
         //배열에서 내가 원하는 것만 빼올 때 사용한다.
         var fruits2 = fruits.slice(1,2);
         console.log(fruits2); //['Lemon'] > 배열 1에서 한개를 가져온다.
         var fruits2 = fruits.slice(1,3);
         console.log(fruits2); //['Lemon', 'Kiwi'] > 배열 1에서 부터 2개를 가져온다.
         var fruits2 = fruits.slice(1);
         console.log(fruits2); //['Lemon', 'Kiwi', 'Kiwi', 'Orange', 'Apple'] > 뒤에 전부 다 가져 온다.

         //sort(); 소트 
         //정렬해주는 역할을 한다.
         console.log(fruits.sort()); //['Apple', 'Banana', 'Kiwi', 'Kiwi', 'Lemon', 'Orange']
         var points = [40,100,70,21,99];
         console.log(points.sort()); // [100, 21, 40, 70, 99] > 숫자인 경우에, 문자로 인식해서, 문자로 바뀐다. 문자에서는 1이 제일 앞에 오는 것이 맞다.
         //var points = ["40","100","70","21","99"];
         //console.log(points.sort());
         points.sort(function(a,b){
            //  if(a > b) {
            //      return 1;
            //  }else if(a < b){
            //      return -1;
            //  }else{
            //      return 0;
            //  }
            return a-b; //오름차순
            return b-a; //내림차순
         });
         //console.log(points); //[21, 40, 70, 99, 100] > 오름차순으로 정렬

         var persons = [
            {name:"유재석", point:78, city:"서울"},
            {name:"김종국", point:92, city:"서울"},
            {name:"양세찬", point:76, city:"제주"},
            {name:"하하", point:81, city:"서울"}
         ];

        persons.sort(function(a,b){
            // if(a.point > b.point) {
            //     return 1;
            // }else if(a.point < b.point){
            //     return -1;
            // }else{
            //     return 0;
            // }

            //return a.point > b.point ? 1 : -1;
            return a.point > b.point ? 1 : a.point < b.point ? -1 : 0;
        });
        console.log(persons);
        // 0: {name: '양세찬', point: 76}
        // 1: {name: '유재석', point: 78}
        // 2: {name: '하하', point: 81}
        // 3: {name: '김종국', point: 92}
        // length: 4

        // reverse() 리버스
        // 배열 저장된 순서를 반대로 바꾼다.
        persons.reverse();
        console.log(persons);
        // 0: {name: '김종국', point: 92}
        // 1: {name: '하하', point: 81}
        // 2: {name: '유재석', point: 78}
        // 3: {name: '양세찬', point: 76}

        //filter()
        //조건에 맞는 배열만 리턴한다.
        var pass = persons.filter(function(person){
            return person.point > 80;
        });
        console.log(pass); // 80점 넘는 배열만 가져 옴
        // 0: {name: '김종국', point: 92}
        // 1: {name: '하하', point: 81}

        //제주 사는 사람만 빼서 사용 가능
        var jeju = persons.filter(function(person){
            return person.city == "제주";
        });
        console.log(jeju);
        //0: {name: '양세찬', point: 76, city: '제주'}
        //필터를 사용하지 않으면, for문으로 하나하나 뽑아 내야 함.
        var jeju = [];
        for(var i=0; i<persons.length ; i++){
            if(persons[i].city == "제주"){
                jeju.push(persons[i]);
            }
        }        
        console.log(jeju);
        //0: {name: '양세찬', point: 76, city: '제주'}

        //reduce 리듀스
        //var total = 0;
        var arr1 = [1,2,3,4];
        // for(var x of arr1){
        //     total += x;
        // }
        // console.log(total); //10

        //reduce 리듀스
        //첫번째 파라메타 - accumulator 어큐뮤래이터 : 누산기
        //두번째 - currentValue 커렌트벨류 : 배열을 읽으면서 현재 값
        //세번째 - 현재 읽고 있는 배열의 index 인덱스 값 > i
        //네번째 - 배열 통째를 사용할 수 있겠금 전달해 준다. > arr
        //reduce(function(a,c,i,arr)
        var total = arr1.reduce(function(a,c){
            return a + c;
        });
        console.log(total); //10

        //map
        //새로운 배열을 만들어 준다.
        //내꺼를 리턴을 하는데, 안에 오브젝트를 새롭게 구성할 때 유용하다.
        //firstName, lastName 더 해주는 것을, 컨켓 함수를 여러군데서 사용하는데 비효율적일 때, 새로운 배열을 만들수 있다.
        //서버에서는 정보를 다 던져주는데, map을 통해서 내가 필요한 정보만 선언해서 사용할 수 있고, 필요한 곳에 전달만 해주면 된다.
        var userList = [
            {firstName:"재석", lastName:"유", email:"yu@gmail.com"},
            {firstName:"종국", lastName:"김", email:"kim@gmail.com"},
            {firstName:"세찬", lastName:"양", email:"yang@gmail.com"},
            {firstName:"석진", lastName:"지", email:"ji@gmail.com"}
        ];

        var userList2 = userList.map(function(user){
            return {fullName:user.lastName + user.firstName,firstName:user.firstName, lastName:user.lastName, email:user.email}
        });
        console.log(userList2);
        // 0: {fullName: '유재석', firstName: '재석', lastName: '유', email: 'yu@gmail.com'}
        // 1: {fullName: '김종국', firstName: '종국', lastName: '김', email: 'kim@gmail.com'}
        // 2: {fullName: '양세찬', firstName: '세찬', lastName: '양', email: 'yang@gmail.com'}
        // 3: {fullName: '지석진', firstName: '석진', lastName: '지', email: 'ji@gmail.com'}
        // length: 4

    </script>
</body>
</html>